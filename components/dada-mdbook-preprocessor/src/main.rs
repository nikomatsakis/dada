use anyhow::{bail, Result};
use clap::{Arg, ArgMatches, Command};
use mdbook::book::{Book, BookItem, Chapter};
use mdbook::preprocess::{CmdPreprocessor, Preprocessor, PreprocessorContext};
use regex::Regex;
use serde::Deserialize;
use std::collections::HashMap;
use std::io;
use std::path::Path;
use std::process;

pub fn make_app() -> Command<'static> {
    Command::new("dada-mdbook-preprocessor")
        .about("An mdbook preprocessor for processing Dada r[...] labels")
        .subcommand(
            Command::new("supports")
                .arg(Arg::new("renderer").required(true))
                .about("Check whether a renderer is supported by this preprocessor"),
        )
}

fn main() {
    let matches = make_app().get_matches();

    let preprocessor = DadaPreprocessor::new();

    if let Some(sub_args) = matches.subcommand_matches("supports") {
        handle_supports(&preprocessor, sub_args);
    } else if let Err(e) = handle_preprocessing(&preprocessor) {
        eprintln!("{}", e);
        process::exit(1);
    }
}

fn handle_supports(pre: &dyn Preprocessor, sub_args: &ArgMatches) -> ! {
    let renderer = sub_args.value_of("renderer").expect("Required argument");
    let supported = pre.supports_renderer(renderer);

    if supported {
        process::exit(0);
    } else {
        process::exit(1);
    }
}

fn handle_preprocessing(pre: &dyn Preprocessor) -> Result<()> {
    let (mut ctx, book) = CmdPreprocessor::parse_input(io::stdin())?;

    let book_version = Version::parse(&ctx.mdbook_version)?;
    let version_req = VersionReq::parse(mdbook::MDBOOK_VERSION)?;

    if !version_req.matches(&book_version) {
        eprintln!(
            "Warning: The {} plugin was built against version {} of mdbook, \
             but we're being called from version {}",
            pre.name(),
            mdbook::MDBOOK_VERSION,
            ctx.mdbook_version
        );
    }

    let processed_book = pre.run(&mut ctx, book)?;
    serde_json::to_writer(io::stdout(), &processed_book)?;

    Ok(())
}

use semver::{Version, VersionReq};

#[derive(Debug, Deserialize)]
struct RfcFrontMatter {
    status: String,
    #[serde(rename = "tracking-issue")]
    tracking_issue: Option<String>,
    #[serde(rename = "implemented-version")]
    implemented_version: Option<String>,
}

#[derive(Debug)]
struct RfcInfo {
    number: String,
    title: String,
    path: String,
    status: String,
    status_display: String,
    tracking_issue: Option<String>,
    implemented_version: Option<String>,
    first_sentence_plain: String,
    full_summary_markdown: String,
}

struct DadaPreprocessor;

impl DadaPreprocessor {
    pub fn new() -> DadaPreprocessor {
        DadaPreprocessor
    }
}

impl Preprocessor for DadaPreprocessor {
    fn name(&self) -> &str {
        "dada-mdbook-preprocessor"
    }

    fn run(&self, ctx: &PreprocessorContext, mut book: Book) -> Result<Book> {
        let re = Regex::new(r"^r\[([^\]]+)\]$").unwrap();

        // First pass: process r[...] labels
        book.for_each_mut(|item: &mut BookItem| {
            if let BookItem::Chapter(chapter) = item {
                // Check if this chapter has any labels
                let has_labels = chapter.content.lines().any(|line| re.is_match(line.trim()));

                // Process the content
                chapter.content = process_r_labels(&chapter.content);

                // If this chapter has labels, inject CSS at the end
                if has_labels {
                    chapter.content.push_str("\n");
                    chapter.content.push_str(&get_inline_css());
                }
            }
        });

        // Second pass: populate RFC sections
        populate_rfc_sections(ctx, &mut book)?;
        
        // Third pass: inject CSS for any chapters with RFC tables
        book.for_each_mut(|item: &mut BookItem| {
            if let BookItem::Chapter(chapter) = item {
                // Check if this chapter has RFC tables (after RFC generation)
                let has_rfc_tables = chapter.content.contains("class=\"rfc-table\"");
                
                // Check if CSS is already injected
                let already_has_css = chapter.content.contains("/* Generated by dada-mdbook-preprocessor");

                // If this chapter has RFC tables and doesn't already have CSS, inject it
                if has_rfc_tables && !already_has_css {
                    chapter.content.push_str("\n");
                    chapter.content.push_str(&get_inline_css());
                }
            }
        });

        Ok(book)
    }

    fn supports_renderer(&self, renderer: &str) -> bool {
        renderer != "not-supported"
    }
}

fn process_r_labels(content: &str) -> String {
    let re = Regex::new(r"^r\[([^\]]+)\]$").unwrap();

    content
        .lines()
        .map(|line| {
            if let Some(captures) = re.captures(line.trim()) {
                let label = &captures[1];
                // Convert to HTML with anchor and styling
                format!(
                    "<div class=\"spec-label\"><a id=\"{}\" href=\"#{}\" class=\"spec-label-link\">r[{}]</a></div>",
                    label, label, label
                )
            } else {
                line.to_string()
            }
        })
        .collect::<Vec<_>>()
        .join("\n")
}

fn get_inline_css() -> String {
    r#"<style>
/* Generated by dada-mdbook-preprocessor - Styling for specification paragraph labels */
.spec-label {
    margin-bottom: 0.25rem;
}

.spec-label-link {
    font-size: 0.75rem;
    color: #666;
    text-decoration: none;
    font-family: 'SFMono-Regular', 'Monaco', 'Inconsolata', 'Fira Code', 'Source Code Pro', monospace;
    background-color: #f6f8fa;
    padding: 0.125rem 0.25rem;
    border-radius: 0.25rem;
    border: 1px solid #e1e8ed;
}

.spec-label-link:hover {
    color: #0366d6;
    background-color: #f1f8ff;
    border-color: #c8e1ff;
    text-decoration: none;
}

/* Dark theme support */
.navy .spec-label-link {
    color: #c5c5c5;
    background-color: #1e1e1e;
    border-color: #404040;
}

.navy .spec-label-link:hover {
    color: #79b8ff;
    background-color: #1c2128;
    border-color: #30363d;
}

/* RFC Table Styling - GitHub-inspired */
.rfc-table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 1.5rem;
    border: 1px solid #d0d7de;
    border-radius: 6px;
    overflow: hidden;
}

.rfc-header-row {
    background-color: #f6f8fa;
    border-bottom: 1px solid #d0d7de;
}

.rfc-header-row:hover {
    background-color: #f1f8ff;
}

.rfc-number {
    width: 60px;
    padding: 12px 16px;
    text-align: center;
    font-weight: 600;
    font-size: 14px;
    color: #656d76;
    background-color: inherit;
}

.rfc-details {
    display: flex;
    align-items: center;
    justify-content: center;
}

.rfc-details summary {
    cursor: pointer;
    list-style: none;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
}

.rfc-details summary::-webkit-details-marker {
    display: none;
}

.rfc-details summary::before {
    content: "▶";
    font-size: 10px;
    margin-right: 6px;
    transition: transform 0.2s ease;
}

.rfc-details[open] summary::before {
    transform: rotate(90deg);
}

.rfc-title {
    padding: 12px 16px;
    font-weight: 600;
    font-size: 14px;
}

.rfc-title a {
    color: #0969da;
    text-decoration: none;
}

.rfc-title a:hover {
    text-decoration: underline;
}

.rfc-summary-row {
    display: none;
}

.rfc-details[open] ~ .rfc-header-row ~ .rfc-summary-row,
.rfc-table:has(.rfc-details[open]) .rfc-summary-row {
    display: table-row;
}

.rfc-summary-content {
    padding: 16px;
    font-size: 13px;
    color: #656d76;
    font-weight: normal;
    border-top: 1px solid #d0d7de;
    background-color: #f8f9fa;
}

.rfc-status {
    width: 120px;
    padding: 12px 16px;
    text-align: center;
    vertical-align: middle;
}

/* Dark theme support for RFC tables */
.navy .rfc-table {
    border-color: #30363d;
}

.navy .rfc-header-row {
    background-color: #21262d;
    border-color: #30363d;
}

.navy .rfc-header-row:hover {
    background-color: #1c2128;
}

.navy .rfc-number {
    color: #7d8590;
}

.navy .rfc-title a {
    color: #58a6ff;
}

.navy .rfc-summary-content {
    border-color: #30363d;
    color: #7d8590;
    background-color: #161b22;
}
</style>"#.to_string()
}

fn populate_rfc_sections(ctx: &PreprocessorContext, book: &mut Book) -> Result<()> {
    // Find the position of the "All RFCs" chapter
    let mut rfc_chapter_index = None;

    for (index, item) in book.sections.iter().enumerate() {
        if let BookItem::Chapter(chapter) = item {
            // Check if this is the All RFCs chapter
            if chapter.name.trim() == "All RFCs" {
                rfc_chapter_index = Some(index);
                break;
            }
        }
    }

    // If we found the All RFCs chapter, populate it
    if let Some(index) = rfc_chapter_index {
        // Get a mutable reference to the chapter
        if let Some(BookItem::Chapter(chapter)) = book.sections.get_mut(index) {
            populate_all_rfcs_section(ctx, chapter)?;
        }
    }

    Ok(())
}

fn populate_all_rfcs_section(ctx: &PreprocessorContext, chapter: &mut Chapter) -> Result<()> {
    let src_dir = ctx.config.book.src.clone();

    // Find all RFC directories
    let mut rfc_dirs = Vec::new();
    if let Ok(entries) = std::fs::read_dir(&src_dir) {
        for entry in entries {
            let entry = entry?;
            let path = entry.path();
            if path.is_dir() {
                if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
                    // Match directories like 0001-feature-name
                    if name.len() > 4
                        && name[..4].chars().all(|c| c.is_ascii_digit())
                        && name.chars().nth(4) == Some('-')
                    {
                        rfc_dirs.push((name.to_string(), path));
                    }
                }
            }
        }
    }

    // Sort by RFC number
    rfc_dirs.sort_by(|a, b| a.0.cmp(&b.0));

    // Process each RFC directory to extract info
    let mut rfcs_by_status: HashMap<String, Vec<RfcInfo>> = HashMap::new();
    
    for (dir_name, dir_path) in rfc_dirs {
        if let Ok(rfc_info) = extract_rfc_info(&dir_path, &dir_name) {
            rfcs_by_status.entry(rfc_info.status.clone())
                         .or_insert_with(Vec::new)
                         .push(rfc_info);
        }
    }

    // Generate HTML content for the all.md page
    let html_content = generate_all_rfcs_html(&rfcs_by_status);
    
    // Replace the chapter content
    chapter.content = format!("# All RFCs\n\n{}", html_content);

    // Process each RFC directory for sub-chapters (keep existing functionality)
    let src_dir = ctx.config.book.src.clone();
    let mut rfc_dirs = Vec::new();
    if let Ok(entries) = std::fs::read_dir(&src_dir) {
        for entry in entries {
            let entry = entry?;
            let path = entry.path();
            if path.is_dir() {
                if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
                    if name.len() > 4
                        && name[..4].chars().all(|c| c.is_ascii_digit())
                        && name.chars().nth(4) == Some('-')
                    {
                        rfc_dirs.push((name.to_string(), path));
                    }
                }
            }
        }
    }
    rfc_dirs.sort_by(|a, b| a.0.cmp(&b.0));

    for ((dir_name, dir_path), index) in rfc_dirs.iter().zip(0..) {
        if let Ok(rfc_chapter) = create_rfc_chapter(&src_dir, dir_name, dir_path, &chapter, index) {
            chapter.sub_items.push(BookItem::Chapter(rfc_chapter));
        }
    }

    Ok(())
}

fn create_rfc_chapter(
    src_dir: &Path,
    dir_name: &str,
    dir_path: &Path,
    all_rfcs_chapter: &Chapter,
    rfc_index: u32,
) -> Result<Chapter> {
    // Read README.md to get the title
    let readme_path = dir_path.join("README.md");
    let readme_content = std::fs::read_to_string(&readme_path)?;

    // Extract title from first # line
    let title = readme_content
        .lines()
        .find(|line| line.starts_with("# "))
        .map(|line| line[2..].trim())
        .unwrap_or(dir_name)
        .to_string();

    // Create relative path for mdbook
    let relative_path = readme_path.strip_prefix(src_dir)?.to_path_buf();

    // Create proper parent names for nested structure
    let mut rfc_parent_names = all_rfcs_chapter.parent_names.clone();
    rfc_parent_names.push(all_rfcs_chapter.name.clone());

    // Get the section number of the parent and convert it to the section number of the new child
    let Some(mut section_number) = all_rfcs_chapter.number.clone() else {
        bail!("All RFCs chapter has no number")
    };
    section_number.push(rfc_index);

    let mut rfc_chapter = Chapter::new(
        &title,
        readme_content,
        relative_path,
        rfc_parent_names.clone(),
    );
    rfc_chapter.number = Some(section_number.clone());

    // Find all other .md files in the directory
    if let Ok(entries) = std::fs::read_dir(dir_path) {
        let mut sub_files = Vec::new();

        for entry in entries {
            let entry = entry?;
            let path = entry.path();

            if path.is_file() && path.extension().and_then(|s| s.to_str()) == Some("md") {
                let file_name = path.file_name().and_then(|n| n.to_str()).unwrap_or("");
                if file_name != "README.md" {
                    sub_files.push(path);
                }
            }
        }

        // Sort sub-files for consistent ordering
        sub_files.sort();

        // Create sub-chapters for each .md file
        let mut sub_parent_names = rfc_parent_names.clone();
        sub_parent_names.push(title.clone());

        for (sub_path, sub_index) in sub_files.iter().zip(0..) {
            if let Ok(sub_content) = std::fs::read_to_string(sub_path) {
                // Extract title from first # line
                let sub_title = sub_content
                    .lines()
                    .find(|line| line.starts_with("# "))
                    .map(|line| line[2..].trim())
                    .unwrap_or_else(|| {
                        sub_path
                            .file_stem()
                            .and_then(|s| s.to_str())
                            .unwrap_or("Untitled")
                    })
                    .to_string();

                let sub_relative_path = sub_path.strip_prefix(src_dir)?.to_path_buf();

                let mut sub_chapter = Chapter::new(
                    &sub_title,
                    sub_content,
                    sub_relative_path,
                    sub_parent_names.clone(),
                );

                // assign the section number for this subchapter
                section_number.push(sub_index);
                sub_chapter.number = Some(section_number.clone());
                section_number.pop().unwrap();

                rfc_chapter.sub_items.push(BookItem::Chapter(sub_chapter));
            }
        }
    }

    Ok(rfc_chapter)
}

fn extract_rfc_info(dir_path: &Path, dir_name: &str) -> Result<RfcInfo> {
    // Read README.md to get the title and content
    let readme_path = dir_path.join("README.md");
    let readme_content = std::fs::read_to_string(&readme_path)?;

    // Parse front matter and content
    let (front_matter, content) = parse_front_matter(&readme_content)?;

    // Extract RFC number from directory name (e.g., "0001-string-literals" -> "0001")
    let number = dir_name[..4].to_string();

    // Extract title from first # line
    let title = content
        .lines()
        .find(|line| line.starts_with("# "))
        .map(|line| line[2..].trim())
        .unwrap_or(dir_name)
        .to_string();

    // Extract summary section
    let summary_section = extract_section(&content, "## Summary");
    
    // Extract first sentence for collapsed view
    let first_sentence_plain = extract_first_sentence_plain(&summary_section);
    
    // Generate status display
    let status_display = format_status(&front_matter.status, &front_matter.tracking_issue, &front_matter.implemented_version);

    Ok(RfcInfo {
        number,
        title,
        path: dir_name.to_string(),
        status: front_matter.status,
        status_display,
        tracking_issue: front_matter.tracking_issue,
        implemented_version: front_matter.implemented_version,
        first_sentence_plain,
        full_summary_markdown: summary_section,
    })
}

fn parse_front_matter(content: &str) -> Result<(RfcFrontMatter, String)> {
    let lines: Vec<&str> = content.lines().collect();
    
    // Check if content starts with front matter
    if lines.is_empty() || !lines[0].trim().starts_with("---") {
        // No front matter, use defaults
        let default_front_matter = RfcFrontMatter {
            status: "draft".to_string(),
            tracking_issue: None,
            implemented_version: None,
        };
        return Ok((default_front_matter, content.to_string()));
    }

    // Find the end of front matter
    let mut end_index = None;
    for (i, line) in lines.iter().enumerate().skip(1) {
        if line.trim() == "---" {
            end_index = Some(i);
            break;
        }
    }

    let end_index = end_index.ok_or_else(|| anyhow::anyhow!("Unclosed front matter"))?;

    // Extract and parse front matter
    let front_matter_text = lines[1..end_index].join("\n");
    let front_matter: RfcFrontMatter = serde_yaml::from_str(&front_matter_text)
        .unwrap_or_else(|_| RfcFrontMatter {
            status: "draft".to_string(),
            tracking_issue: None,
            implemented_version: None,
        });

    // Extract content after front matter
    let content_lines = if end_index + 1 < lines.len() {
        &lines[end_index + 1..]
    } else {
        &[]
    };
    let content = content_lines.join("\n");

    Ok((front_matter, content))
}

fn extract_section(content: &str, heading: &str) -> String {
    let lines: Vec<&str> = content.lines().collect();
    let mut in_section = false;
    let mut section_lines = Vec::new();
    
    for line in lines {
        if line.starts_with("## ") {
            if line.trim() == heading {
                in_section = true;
                continue; // Skip the heading itself
            } else if in_section {
                break; // Hit next section, stop
            }
        }
        
        if in_section {
            section_lines.push(line);
        }
    }
    
    section_lines.join("\n").trim().to_string()
}

fn extract_first_sentence_plain(markdown: &str) -> String {
    // First, remove code blocks to avoid sentence splitting inside them
    let without_code_blocks = remove_code_blocks(markdown);
    
    // Strip other markdown syntax
    let plain_text = strip_markdown_inline(&without_code_blocks);
    
    // Find first sentence (. ! or ?)
    let first_sentence = find_first_sentence(&plain_text);
    
    // Truncate if too long
    if first_sentence.len() > 120 {
        format!("{}...", &first_sentence[..117])
    } else {
        first_sentence.to_string()
    }
}

fn remove_code_blocks(text: &str) -> String {
    let mut result = String::new();
    let mut chars = text.chars().peekable();
    let mut in_inline_code = false;
    let mut in_code_block = false;
    
    while let Some(ch) = chars.next() {
        if ch == '`' {
            // Check for triple backticks
            if chars.peek() == Some(&'`') {
                chars.next(); // consume second `
                if chars.peek() == Some(&'`') {
                    chars.next(); // consume third `
                    in_code_block = !in_code_block;
                    // Skip the rest of the line if starting a code block
                    if in_code_block {
                        while let Some(c) = chars.next() {
                            if c == '\n' { break; }
                        }
                    }
                    continue;
                }
            } else if !in_code_block {
                // Single backtick - inline code
                in_inline_code = !in_inline_code;
                continue;
            }
        }
        
        if !in_code_block && !in_inline_code {
            result.push(ch);
        }
    }
    
    result
}

fn strip_markdown_inline(text: &str) -> String {
    let re_link = Regex::new(r"\[([^\]]+)\]\([^)]+\)").unwrap();
    
    let result = text
        .replace("**", "")           // Bold
        .replace("*", "")            // Italic  
        .replace("`", "");           // Code
    
    // Handle links: [text](url) → text
    re_link.replace_all(&result, "$1").to_string()
}

fn find_first_sentence(text: &str) -> String {
    // Look for sentence endings: . ! ?
    // But make sure they're followed by whitespace or end of string
    let sentence_endings = ['.', '!', '?'];
    
    for (i, ch) in text.char_indices() {
        if sentence_endings.contains(&ch) {
            // Check if next character is whitespace or end
            let next_char = text.chars().nth(i + 1);
            if next_char.is_none() || next_char == Some(' ') || next_char == Some('\n') {
                return text[..=i].trim().to_string();
            }
        }
    }
    
    // If no sentence ending found, return the whole text
    text.trim().to_string()
}

fn format_status(status: &str, tracking_issue: &Option<String>, implemented_version: &Option<String>) -> String {
    let (color, label) = match status {
        "active" => ("blue", "Active"),
        "accepted" => ("green", "Accepted"),
        "implemented" => ("brightgreen", "Implemented"),
        "draft" => ("lightgrey", "Draft"),
        "rejected" => ("red", "Rejected"),
        "withdrawn" => ("red", "Withdrawn"),
        _ => ("lightgrey", "Unknown"),
    };
    
    let mut badge_text = label.to_string();
    
    // Add version info if implemented
    if let Some(version) = implemented_version {
        badge_text = format!("{} v{}", badge_text, version);
    }
    
    // Add tracking issue if present
    if let Some(issue) = tracking_issue {
        if issue.chars().all(|c| c.is_ascii_digit()) {
            badge_text = format!("{} %23{}", badge_text, issue); // %23 is URL-encoded #
        } else if issue.starts_with('#') {
            let issue_num = &issue[1..];
            if issue_num.chars().all(|c| c.is_ascii_digit()) {
                badge_text = format!("{} %23{}", badge_text, issue_num);
            }
        }
    }
    
    // URL encode spaces and other characters
    let encoded_text = badge_text.replace(" ", "%20");
    
    let badge_url = format!("https://img.shields.io/badge/Status-{}-{}", encoded_text, color);
    
    // Generate HTML img tag instead of markdown since we're in an HTML table
    if let Some(issue) = tracking_issue {
        if issue.chars().all(|c| c.is_ascii_digit()) || (issue.starts_with('#') && issue[1..].chars().all(|c| c.is_ascii_digit())) {
            let issue_num = if issue.starts_with('#') { &issue[1..] } else { issue };
            let github_url = format!("https://github.com/dada-lang/dada/issues/{}", issue_num);
            format!("<a href=\"{}\"><img src=\"{}\" alt=\"RFC Status\" /></a>", github_url, badge_url)
        } else {
            format!("<img src=\"{}\" alt=\"RFC Status\" />", badge_url)
        }
    } else {
        format!("<img src=\"{}\" alt=\"RFC Status\" />", badge_url)
    }
}

fn generate_all_rfcs_html(rfcs_by_status: &HashMap<String, Vec<RfcInfo>>) -> String {
    let mut content = String::new();
    
    content.push_str("This page provides an overview of all RFCs (Request for Comments) in the Dada language development process.\n\n");
    
    // Define status order for display
    let status_headers = [
        ("active", "Active RFCs", "RFCs currently under discussion and development."),
        ("accepted", "Accepted RFCs", "RFCs that have been accepted but not yet implemented."), 
        ("implemented", "Implemented RFCs", "RFCs that have been fully implemented and are part of the language."),
        ("draft", "Draft RFCs", "RFCs that are still being written or refined."),
        ("rejected", "Rejected/Withdrawn RFCs", "RFCs that were not accepted or were withdrawn."),
    ];
    
    for (status, header, description) in status_headers {
        if let Some(rfcs) = rfcs_by_status.get(status) {
            if !rfcs.is_empty() {
                content.push_str(&format!("## {}\n\n", header));
                content.push_str(&format!("{}\n\n", description));
                content.push_str(&generate_rfc_table_html(rfcs));
                content.push_str("\n");
            } else {
                // Show empty sections for non-draft/rejected statuses
                if status != "rejected" {
                    content.push_str(&format!("## {}\n\n", header));
                    content.push_str(&format!("{}\n\n", description));
                    content.push_str("*(None yet)*\n");
                    content.push_str("\n");
                }
            }
        } else {
            // Show empty sections for non-draft/rejected statuses
            if status != "rejected" {
                content.push_str(&format!("## {}\n\n", header));
                content.push_str(&format!("{}\n\n", description));
                content.push_str("*(None yet)*\n");
                content.push_str("\n");
            }
        }
    }
    
    content
}

fn generate_rfc_table_html(rfcs: &[RfcInfo]) -> String {
    let mut html = String::new();
    
    for rfc in rfcs {
        let rfc_number = rfc.number.parse::<u32>().unwrap_or(0);
        // ⚠️ IMPORTANT: The blank lines around {} in rfc-summary-content are REQUIRED!
        // They allow mdbook's markdown processor to parse markdown inside HTML blocks.
        // Without these newlines, content like `code` and **bold** won't be rendered.
        html.push_str(&format!(
            r#"<table class="rfc-table">
<tr class="rfc-header-row">
<td class="rfc-number">
<details class="rfc-details">
<summary>{}</summary>
</details>
</td>
<td class="rfc-title"><a href="./{}/README.md">{}</a></td>
<td class="rfc-status">{}</td>
</tr>
<tr class="rfc-summary-row">
<td colspan="3" class="rfc-summary-content">

{}

</td>
</tr>
</table>

"#,
            rfc_number,
            rfc.path,
            rfc.title,
            rfc.status_display,
            rfc.full_summary_markdown.trim()
        ));
    }
    
    html
}
